# XML-to-YAML-parser
XML to YAML parser
Задания:

 
Обязательное задание (позволяет набрать до 65 процентов от максимального числа баллов БаРС за данную лабораторную): написать программу на языке Python 3.x, которая бы осуществляла парсинг и конвертацию исходного файла в новый. 

 
Дополнительное задание №2 (позволяет набрать +10 процентов от максимального числа баллов БаРС за данную лабораторную). 
a) Переписать исходный код, добавив в него использование 
регулярных выражений. 2 
	b) Сравнить полученные результаты и объяснить их сходство/различие. 

Варинат 29
Исходный формат XML 
Результирующий формат YAML
День недели Пятница

Используемые источники для парсинга HTML  в XML, XML в YAML.
https://onlineconvertfree.com/ru/convert-format/html-to-xml/
https://codebeautify.org/xml-to-yaml

Используемые источники для проверки валидности результата файла формата YAML .
https://yamlchecker.com/ 

Используемые и подключаемые библиотеки в архиве с названиями
xml_parser.py
xml_lexer.py

Основные этапы выполнения работы.

1)	Работа с файлами, считывание из файла и запись в файл.
В функции def reading():
2)	Реализован построчный парсинг. Итоговый YAML файл формируется из условий расположения элементов в считываемой строке.
3)	Реализация функций для обработки считанной строки.

def get_spaces(a):

4)	Получает на вход исходную строку и считывает количество пробелов, для контроля разметки исходного XML файла и возвращает количество отступов для Результирующего файла. Т.к для файла YAML важно сохранять разметку длявалидности.
5)	def get_tags(a):
6)	Получает на вход исходную строку и контролирует повторяющиеся названия. Это важно для получения валидности YAML файла. Формирует теги(ключи), которые далее переиспользуются в результирующем файле.

def get_value(a):
7)	Получает на вход считанную строку и формирует значение ключа в итоговом файле YAML.
8)	def correct(a):
9)	проверяет является ли строка корректной для ее обработки
10)	def reading():
Главная функция, переиспользующая остальные для считывания строки из XML и формирования новой строки в YAML файле с учетом отступов, вложенности, ключей, значений, считываемых элементов. В ней реализована работа с файлами.


Доп. Задание 2

import xml_parser

Импортировав готовую библиотеку парсинга файла XML в YAML, с использованием таких регулярных выражений, как
tag_re = re.compile(
    r"""^(?!<[xX][mM][lL])
    (<\s*([a-zA-Z_][-a-zA-Z_.\d]*)
    ((\s*[a-zA-Z_][-a-zA-Z_.\d]*=(['\"]).*\5)*)
    \s*(/)?>|</\s*([a-zA-Z_][-a-zA-Z_.\d]*)\s*>)""",
    re.X)
и многих других
Для импортирования файла xml_parser необходимо подключить еще одну библиотеку, в который и реализованы регулярные выражения.
В ней реализована работа с файлами и аналогичная работа с тегами
 получает на вход исходный файл XML и выводит результат в еще один файл в архиве test2

Вывод: Построчное считывание строк из исходного файла является прямолинейным решением, которое может быть быстро реализовано, но может потеряться логика построения YAML файла, в особых случаях, также следить за всеми повторяющимися тегами можно через стэк, как это и реализовано в подключаемых библиотеках. Еще одной особенностью Реализации программы через стек(библиотека) является надежность и уверенность в парсинге любого файла формата XML, потому что теги(ключи) могут принимать объемное количество названий, и следить за ними, условием if else не разумно.
Это всё, что я могу написать за 7 часов из-за загруженности, но на 65 думаю точно потянет.






